# Flatyd

Flatyd generate flat typed dicts from nested data structures. Use these generated types to define type-safe string-based APIs for accessing structured data.

## Why

Consider this a motivating example: we have an application that has a nested configuration.

```python
class S3Config:
    """AWS S3-specific configuration"""
    region: str
    endpoint_url: str
    access_key_id: str

class RuntimeConfig:
    """Runtime-specific configuration"""
    max_mem_gb: int
    num_threads: int

class MainConfig:
    """Configuration for our application"""
    runtime: RuntimeConfig
    s3: S3Config
```

Suppose we want a *flat* API for accessing our configuration. Like this:

```python

# Get MainConfig.s3.region
MainConfig.get('s3.region')

# update MainConfig.runtime.num_threads
MainConfig.set('runtime.num_threads', 3)
```

How can we make this API type-safe? To inform the type checker that `get("runtime.num_threads")` should
return an `int`, we need to define some types. Here's what the types would look like for a
flattened API in this example:

```python
from typing_extensions import TypedDict, Literal, Protocol, Union
from typing import overload, TypeAlias

MainConfigFlatyd = TypedDict(
    'MainConfigDict', {
        'runtime': "RuntimeConfig",
        'runtime.max_mem_gb': int,
        'runtime.num_threads': int,
         's3': "S3Config",
         's3.region': str,
         's3.endpoint_url': str,
         's3.access_key_id': str})

MainConfigFlatydKey = Literal[
    "runtime",
    "runtime.max_mem_gb",
    "runtime.num_threads",
    "s3",
    "s3.region",
    "s3.endpoint_url",
    "s3.access_key_id"
    ]
"""Valid keys for querying the flattened TypedDict."""

MainConfigDictValue: TypeAlias = Union["RuntimeConfig", int, "S3Config", str]
"""Union of value types for the flattened TypedDict."""

class MainConfigFlatydGetter(Protocol):
    """Getter protocol for the flattened TypedDict."""
    @overload
    def __call__(self, key: Literal["runtime"]) -> "RuntimeConfig": ...
    @overload
    def __call__(self, key: Literal["runtime.max_mem_gb"]) -> int: ...
    @overload
    def __call__(self, key: Literal["runtime.num_threads"]) -> int: ...
    @overload
    def __call__(self, key: Literal["s3"]) -> "S3Config": ...
    @overload
    def __call__(self, key: Literal["s3.region"]) -> str: ...
    @overload
    def __call__(self, key: Literal["s3.endpoint_url"]) -> str: ...
    @overload
    def __call__(self, key: Literal["s3.access_key_id"]) -> str: ...
    @overload
    def __call__(self, key: MainConfigDictKey) -> MainConfigDictValue: ...

class MainConfigFlatydSetter(Protocol):
    """Setter protocol for the flattened TypedDict."""
    @overload
    def __call__(self, key: Literal["runtime"], value: "RuntimeConfig") -> None: ...
    @overload
    def __call__(self, key: Literal["runtime.max_mem_gb"], value: int) -> None: ...
    @overload
    def __call__(self, key: Literal["runtime.num_threads"], value: int) -> None: ...
    @overload
    def __call__(self, key: Literal["s3"], value: "S3Config") -> None: ...
    @overload
    def __call__(self, key: Literal["s3.region"], value: str) -> None: ...
    @overload
    def __call__(self, key: Literal["s3.endpoint_url"], value: str) -> None: ...
    @overload
    def __call__(self, key: Literal["s3.access_key_id"], value: str) -> None: ...
    @overload
    def __call__(self, key: MainConfigDictKey, value: MainConfigDictValue) -> None: ...
```

This is a *lot* of boilerplate, and it will quickly become a burden if we make changes to `MainConfig`.
Ideally, the Python type system would copy TypeScript and provide operators that make it easy to
define these types directly in the type system. But until then, we have to write the types explicitly.
That's where Flatyd is useful: it generates utility types for a flat representation of an original nested type.

```python
from flatyd import flatyd_inline
from typing_extensions import TypedDict, Literal, Protocol, Union
from typing import overload, TypeAlias

class S3Config:
    """AWS S3-specific configuration"""
    region: str
    endpoint_url: str
    access_key_id: str

class RuntimeConfig:
    """Runtime-specific configuration"""
    max_mem_gb: int
    num_threads: int

class MainConfig:
    """Configuration for our application"""
    runtime: RuntimeConfig
    s3: S3Config

# These types are automatically generated by flatyd
@flatyd_inline(MainConfig, key_delimiter=".")
# <flatyd:autogenerated>
class MainConfigDict: ...
MainConfigDict = TypedDict('MainConfigDict', {'runtime': "RuntimeConfig", 'runtime.max_mem_gb': int, 'runtime.num_threads': int, 's3': "S3Config", 's3.region': str, 's3.endpoint_url': str, 's3.access_key_id': str})  # noqa: F811
"""
Auto-generated flattened TypedDict for MainConfigDict.

This type was automatically generated by flatyd.
Do not edit manually - re-run `flatyd generate` to update.
"""

MainConfigDictKey = Literal["runtime", "runtime.max_mem_gb", "runtime.num_threads", "s3", "s3.region", "s3.endpoint_url", "s3.access_key_id"]
"""Valid keys for querying the flattened TypedDict."""

MainConfigDictValue: TypeAlias = Union["RuntimeConfig", int, "S3Config", str]
"""Union of value types for the flattened TypedDict."""

class MainConfigDictGetter(Protocol):
    """Getter protocol for the flattened TypedDict."""
    @overload
    def __call__(self, key: Literal["runtime"]) -> "RuntimeConfig": ...
    @overload
    def __call__(self, key: Literal["runtime.max_mem_gb"]) -> int: ...
    @overload
    def __call__(self, key: Literal["runtime.num_threads"]) -> int: ...
    @overload
    def __call__(self, key: Literal["s3"]) -> "S3Config": ...
    @overload
    def __call__(self, key: Literal["s3.region"]) -> str: ...
    @overload
    def __call__(self, key: Literal["s3.endpoint_url"]) -> str: ...
    @overload
    def __call__(self, key: Literal["s3.access_key_id"]) -> str: ...
    @overload
    def __call__(self, key: MainConfigDictKey) -> MainConfigDictValue: ...

class MainConfigDictSetter(Protocol):
    """Setter protocol for the flattened TypedDict."""
    @overload
    def __call__(self, key: Literal["runtime"], value: "RuntimeConfig") -> None: ...
    @overload
    def __call__(self, key: Literal["runtime.max_mem_gb"], value: int) -> None: ...
    @overload
    def __call__(self, key: Literal["runtime.num_threads"], value: int) -> None: ...
    @overload
    def __call__(self, key: Literal["s3"], value: "S3Config") -> None: ...
    @overload
    def __call__(self, key: Literal["s3.region"], value: str) -> None: ...
    @overload
    def __call__(self, key: Literal["s3.endpoint_url"], value: str) -> None: ...
    @overload
    def __call__(self, key: Literal["s3.access_key_id"], value: str) -> None: ...
    @overload
    def __call__(self, key: MainConfigDictKey, value: MainConfigDictValue) -> None: ...
# </flatyd:autogenerated>

```

## Usage

### Type generation


"""
```
